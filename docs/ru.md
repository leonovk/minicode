# Руководство по языку

Миникод выполняет код построчно, предварительно компилируя его в некий набор команд. Что делает его классическим интерпретируемым языком программирования. Каждая строка кода в миникоде начинается с команды, затем идет выражение.

На данный момент в миникоде есть 12 команд и 3 типа данных, целые числа, строки и массивы.
Целые числа ведут себя точно также как в Lua. Если вы не используете символы после запятой, они будут целыми, в противном случае не целыми. В любом случае и те и другие в памяти будут храниться как не целые.

Миникод является тьюринг полным языком и в теории позволяет реализовать любую функцию.

| команда | описание |
|----------|----------|
| >    | Создание новой переменной  |
| []   | Инициализация пустого массива |
| []<  | Добавить новый элемент в конец массива |
| p    | Вывести на экран содержимое переменной   |
| f    | Чтение из файла и запись его содержимого в переменную  |
| $>   | Запросить значение у пользователя |
| =    | Начало арифметической операции |
| ?    | Начало условия |
| >>   | Записать данные в файл |
| &    | Выполнить команду ОС |
| ->   | Подключить файл с кодом |
| -_-  | Остановить поток выполнения кода |

Каждая строка начинается с одной из эти команд и отделяется от выражений пробелом.

## Создание переменных

После символа операции создания переменной всегда идет ее имя. Объявлять тип переменной при создании не требуется. Миникод сам обозначит тип. Также если не передать никакое значение, то значение переменной будет равно пустой строке - "".

Тут в переменной 'a' будет лежать пустая строка.

```mc
> a
```

Тут в переменной 'a' будет лежать число 324.

```mc
> a 324
```

Тут в переменной 'a' будет лежать строка - "hello world"

```mc
> a hello world
```

Обратите внимание, что вам не нужно использовать двойные кавычки для обозначения строк. Миникод сам поймет строку вы имели в виду или другую переменную.

Если передать в качестве второго аргумента строку, то миникод попытается найти ранее обозначенную переменную с таким именем, и если он ее найдет, то скопирует ее значение в новую переменную.

Тут в переменной b будет лежать число 324.

```mc
> a 324
> b a
```

Можно также передавать сразу много значений и в зависимости от ранее созданных переменных будет тот или иной результат.

Например, если мы хотим скопировать в новую переменную не всю строку, а только конкретный символ из конкретной строки в другой переменной, мы можем сделать так:

Тут в переменной b будет лежать строка - "e"

```mc
> a hello
> b a 1
```

Также можно выбирать элементы из массива.

Создаются массивы следующим образом:

```mc
# тут в переменной а инициалиризуем пустой массив.
[] a

# тут кладем в конец массива новое значение
[]< a 43
```

Пример, как заполнить массив символами из слова 'hello'

```mc
# Сначало заполняем массив

[] a
> empty_line
> word hello
> i 0
> char word i
[]< a char
= i + 1
? char ! empty_line 7

# Затем выбираем из него нужные элементы, кладем их в переменные
# и печатаем на экран

> h a 0
> e a 1
> l a 2
> ll a 3
> o a 4

p h
p e
p l
p ll
p o
```

В качестве индекса в таких случаях также может выступать значение других переменных. Если по адресу переменной 'a' ничего не будет найдено, то будет просто создана новая строка - "a 1".

## Вывод значений в консоль

Вывод значений в консоль работает очень просто.

Команда `p` принимает только 1 единственный аргумент и выводит его значение на экран

```mc
p a
```

## Чтение из файла

Используя команду `f` можно прочитать содержимое любого файла и записать его в переменную.

Все содержимое файла будет помещено в переменную 'a' как обычная строка.

```mc
f a test/test_file.txt
```

## Запрос значение у пользователя

Используя команду `$>` можно запрашивать значения у пользователей. Значение также будет перемещено в переменную, в соответствии с ее типом. Тип миникод определит самостоятельно. Стоит отметить, что все значения запрашиваемые у пользователей таким образом, будут запрошены до выполнения кода. Затем код будет выполняться обычным образом, где команда запроса будет преобразована в команду создания обычной переменной, со значением, который указал пользователей.

```mc
$> a
```

Также вторым аргументом можно передать текст, который будет выведен на экран, в момент запроса значения.

```mc
$> a text
```

## Арифметические операции

Арифметические операции начинаются с команды `=` далее обязательно идет переменная которам будет изменена в ходе дальнейшей операции. Исходная переменная обязательно будет изменена.

Например, так можно увеличить значение переменной 'a' на 12

```mc
= a + 12
```

Так же можно складывать и переменные между собой.

В результате данной операции переменная 'a' будет увеличена на значение переменной 'b'

```mc
= a + b
```

То же самое работает с вычитанием, умножением и делением.

Пример программы которая выводит на экран слово 'hello' построчно:

```mc
> empty_line
> a hello
> i 0
> char a i
p char
= i + 1
? char ! empty_line 4
```

Если вам необходимо найти сумму двух чисел вы можете сделать так:

```mc
> int1 23
> int2 32
> sum 0
> sum + int1
> sum + int2
```

Аналогично можно рассчитать разность и тд.

## Условия и циклы

Условия и циклы реализуются путем перевода интерпретатора на нужную строку. Соответственно если перевести интерпретатор назад, можно создать цикл, если вперед, условное ветвление.
В любом случае и то и то начинается с команды условия.

Команда условия принимает выражение которое должно вернуть истину и номер строки, на которой перейдет интерпретатор если условие истинно.

Данная операция переводит интерпретатор на 5 строчку если значение в переменной 'a' равно нулю.

```mc
? a = 0 5
```

Также есть операция "не равно":

```mc
? a ! 0 5
```

Сравнивать можно также и переменные между собой. Единственное условие переменные должны быть одного типа.

```mc
? a = b 5
```

Следующий код выведет на экран только 'just text'

```mc
> a lol
> b lol
? a = b 6
p a
p b
> c 245
> d 345
? c ! d 11
p c
p d
> text just text
p text
```

Поддерживаются также операторы больше или меньше '>', '<'

## Запись данных в файл

С помощью команды '>>' можно легко записать в файл содержимое любой переменной или указанной строки. С начало всегда идет путь к файлу. Файл не будет перезаписан, если таковой уже имеется

Например:

```mc
> a hello world
>> test/test.txt a
```

Также будут сохранены все символы переноса строки.

## Выполнить команду ОС

С помощью команды '&' можно легко выполнить любую команду вашей операционной системы. Результат выполнения будет положен в переменную. В данном случае не требуется создаваться переменную заранее. Миникод сам создаст ее если ее нет, или заменит ее содержимое если она есть.

Например, вот так можно записать в переменную текущую версию вашего миникода:

```mc
& a minicode --version
```

## Подключить файл с кодом

Вы можете подключить другой файл с исходным кодом на миникоде, в ваш файл. Код из другого файла будет выполнен сразу.

```mc
-> tests/examples/hello_world.mcode
```

Точно так же как и при запуске обычного миникод кода, вы можете передавать аргументы командой строки, который будут доступны как ARG_1, ARG_2 и так далее по списку

Если указать длинную стрелочку в качестве команды, как на примере ниже, то следующий код будет выполняться асинхронно.

```mc
--> tests/examples/hello_world.mcode
```

## Некоторые примеры

### Последовательность фибоначчи

Код запрашивает у юзера максимальное число, до которого необходимо построить последовательность

```mc
$> max
> i 0
> first 0
> second 1
p first
p second
> sum 0
= sum + first
= sum + second
= first + second
= second + sum
= i + 1
? i ! max 5
```
